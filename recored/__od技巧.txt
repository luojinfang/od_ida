.faq names窗口查找目标，怎样跳到下一个
.faq 调试运行时，切换模块时怎样断点
.faq 条件断点怎样判断空值？
.faq od的断点信息怎样导入导出

.faq 怎样方便的导出调用栈,完整的 stack
-------------------------------
//为指向的地址赋值,用 段寄存器:[基址]，如下面的 ds:[ecx]
6621EECD    8B4D 0C         mov ecx,dword ptr ss:[ebp+C]  //ss:[ebp+C] 为 传入的上层参数 ss:[ebp+C] 地址,好友ID  
6621EED0    8901            mov dword ptr ds:[ecx],eax

-------------------------------
-------------------------------
-------------------------------
-------------------------------
-------------------------------
-------------------------------

//运行脚本
在反汇编窗口右键--运行脚本就行了，一些OD没有这个功能


	
---------------- 实例.在可变跳转 eip处和跳转的目标方法处断点.  脚本在跳转eip处 LOG ecx 后run继续, 在响应方法处断点时暂停
START:
	CMP eip,3082E85A
	JNE exit
	LOG ecx
	run
	JMP START
exit:
	PAUSE
-------	 
 
	

//脚本在断点后才触发
START:  //循环
	CMP eip,3082E85A   //比较
	JNE exit  //条件不相等时,跳到exit
	LOG ecx   //打印ecx值到log栏
	run			//继续执行
	JMP START   //跳转到 START
exit:
	PAUSE
	 

	 
-------实例
START:
	CMP eip,3082940E
	JNE exit
	
	CMP ecx,3097F1A8
	JE exit	
	CMP ecx,30987520
	JE exit
	
	LOG ecx
	 
exit:
	run
	JMP START	 
------- 
-------------------------------
断点后，按ctrl+f9，走到最后一个ret,可以一步步看上一帧是从哪里调过来的当前调用栈回到上一帧
-------------------------------
https://blog.csdn.net/cssxn/java/article/details/82819081
0） ALT+K 查看调用堆栈
使用od破解软件时，经常会用到栈回溯的方法，假设我们现在所在main个函数的入口点

使用alt+k来查看此函数的父级调用

堆栈调用窗口显示的每一行，代表从上一层函数，进入当前函数的入口，这个功能缺点就是只能在程序运行到某个函数中，并且断下来后，才能使用。

1) CTRL+K
假设我们有这样的需求，我不想运行到某个函数，只想查看该函数的调用关系。

我想知道谁调用了它？
我想知道它又调用了哪些函数？
这时候使用CTRL+K可以清楚的看到某个函数的上一层，以及这个函数内部调用了那些方法


第一列 显示的是main函数的上一层函数是谁
第二列 显示的是当前的函数
第三列显示的是当前函数内部调用了那些函数
在任意一列，双击，可以把双击的那一列，作为当前函数，进一步追踪。 

2) CTRL+R 交叉引用
我们知道，IDA中有个很强大的功能，就是查看某个函数或者变量的交叉引用。同样OD中也这样的功能
我在main函数的入口点，按下CTRL+R，可以看到谁引用了这个函数入口的地址。

-------------------------------
在C窗口,右键->查找->查找注释 

-------------------------------
栈里显示的返回没有 from 时，说明这个调用是动态的,比如 6510C510  |.  FFD2          call edx

0012ECD0  |651346B3  RETURN to LoginPan.651346B3 from LoginPan.6512EABB
0012ECF8  |6510C512  RETURN to LoginPan.6510C512

-------------------------------
最后一个退出的OD会保留断点配置
-------------------------------
查看内存命令

格式: dd+空格+地址值(具体数值,当要查看指针指向的内容时,要用[]取出指针地址值)

dd 0x013456ec  //快捷命令地址是十六进制

//偏移地址
dd ss:[ebp]+0xc
dd ss:[ebp+0xc]   
dd ebp //ebp 为地址值
dd [ebp] //ebp为指向地址的指针， []为取这个地址的值 , dd 在 []运算后，再查看对应的地址


-------------------------------
在寄存器窗口
寄存器名字右键,有个 hw-break[esp] 可以在esp切换时断点？
-------------------------------
条件断点
//偏移地址
ss:[ebp+0xc]==0x1c
----
02BFE41C      7667779 //  0x75 0043
02BFE41C  43 00 75 00     //od是 32位.在dump窗口里看是左低右高,每个数据4字节  

eax==0x750043   //取ax 的值等于0x750043
[eax]==0x750043   //取ax地址指向的值等于0x750043
[eax]&0xff==0x43  //取ax地址指向的值的第一个字节 等于0x43
----
-------------------------------
在C窗口的 数据dump区, 选择内容，右建显示菜单一般默认选择是 long->address. 如想显示字符串，可选择 long->address with ASKII...
也可以选择右键 -> TEXT 
-------------------------------
在 createProcessW断点，在windows任务栏看当前进程PID, 继续运行后再看新增进程PID是大还是小， 在双开的第二个OD里,attach时选择对应的.

-------------------------------
在M窗口可查看内存
用 CTRL+B 搜索内存中的字符串。


------------------
//条件断点
https://blog.csdn.net/q123456789098/article/details/50502405

//OK
[UNICODE ebx]=="aa1197663"     //注意 ebx是存的是字符串的地址. 如果ebx存的是一个指向地址的地址，则要用  [UNICODE [ebx]]=="aa1197663"


假设当CreateFile打开"c:\\1212.txt"时实现中断，则shift+F2

键入字符 [STRING[esp+4]] =="c:\\1212.txt"

用OD帮助文档解释下:

[esp+4] - 在地址esp+4处的无符号双字内容

STRING 123456 - 以地址123456作为开始，以零作为结尾的ASCII字符串。中括号是必须的，因为您要显示内存的内容
[STRING 123456]=="Brown fox" - 如果从地址0x00123456开始的内存为ASCII字符串"Brown fox"、"BROWN FOX JUMPS"、 "brown fox???"，或类似的串，那么其值为1。比较不区分大小写和文本长度



EAX=="Brown fox" - 同上，EAX按指针对待。

UNICODE [EAX]=="Brown fox" - OllyDbg认为EAX是一个指向UNICODE串的指针，并将其转换为ASCII，然后与文本常量进行比较



运行，断了下来

 也可直接在CMD框中输入bp CreateFileA,[STRING[esp+4]]=="c:\\1212.txt"(注意CreateFileA大小写别错了，中间有无逗号没有影响）

如果是UNICODE，就用[UNICODE[ESP+4]]=="c:\\1212.txt"

------------------