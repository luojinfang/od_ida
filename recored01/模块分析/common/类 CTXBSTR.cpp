
/*
Name                                  Address  Ordinal
----                                  -------  -------
CTXBSTR::CTXBSTR(_GUID const &)       523F18B0 79     
CTXBSTR::CTXBSTR(CTXBSTR const &)     523F1870 80     
CTXBSTR::CTXBSTR(CTXStringW const &)  523F1870 81     
CTXBSTR::CTXBSTR(int)                 523F16B0 82     
CTXBSTR::CTXBSTR(int,wchar_t const *) 523F1730 83     
CTXBSTR::CTXBSTR(wchar_t const *)     523F1750 84     
CTXBSTR::CTXBSTR(void)                523F1650 85     


//CTXBSTR[20], (DWORD)为字符串内存地址; dump ecx+14 (14是十六进制), 和 CTXString 一样


*/


//====================================================================================================================================================
//CTXBSTR::CTXBSTR(wchar_t const *)     523F1750 84     
void **__thiscall CTXStringW::CTXStringW(void **this, void *Src)
{
  void *v2; // ebx@1
  int v3; // esi@1
  void **v4; // edi@1
  _WORD *v5; // eax@2
  int *v6; // ecx@5
  struct CTxStringMgr *v7; // eax@5
  _DWORD *v8; // eax@5
  bool v9; // zf@5
  _BYTE *v10; // eax@8
  char *v12; // eax@11
  int v13; // eax@11
  int v14; // [sp+Ch] [bp-Ch]@3
  int v15; // [sp+10h] [bp-8h]@5
  int v16; // [sp+14h] [bp-4h]@5

  v2 = Src;
  v3 = 0;
  v4 = this;
  if ( !Src )
    goto LABEL_17;
  v5 = Src;
  if ( !*(_WORD *)Src )
    goto LABEL_17;

  do
  {
    v14 = v3;
    ++v5;
    ++v3;  //计算字符串 Src 长度,按_WORD算
  }
  while ( *v5 );
  
  if ( v3 )
  {
    v16 = sub_523F4BB0(Src, 2 * v3); //字符串加密处理,生成sign？ //----------------->
    v7 = TxGetDefaultStringManager(v6);
    v8 = sub_523F4FD0(v7, v3, 2, (int)v2, 2 * v3, v16, &v15); //CTXBSTR实例,创建内存----------------->
    v9 = v15 == 0;
    Src = v8;
    *v4 = v8 + 5; //字符串地址  //CTXBSTR[20], (DWORD)为字符串内存地址 
    if ( v9 )
    {
      if ( v3 < 0 || v14 >= v8[3] >> 1 >> 1 )
        sub_522AF120(-2147024809);
      v8[4] = 2 * v3;	//CTXBSTR[16], (DWORD)为字符串内存占用长度 
      *((_WORD *)*v4 + v3) = 0; //结束符
	  //523F17EC
      memcpy(*v4, v2, 2 * v3);   //拷贝字符串
      v10 = Src;
      *((_DWORD *)Src + 2) = v16;  //CTXBSTR[8], (DWORD)为字符串 sign 
	  //523F17FD
      if ( v10[12] & 1 )
      {
        sub_523F51F0(&Src);
        if ( Src != (char *)*v4 - 20 )
        {
		  //523F181E
          *v4 = (char *)Src + 20; //
          return v4;
        }
      }
    }
  }
  else
  {
LABEL_17:
    v12 = (char *)TxGetDefaultStringManager((int *)this) + 20;
    *v4 = v12; //获得默认的值 0
    v13 = (int)(v12 - 20);
    if ( v13 != dword_52528F6C )
      InterlockedIncrement((volatile LONG *)(v13 + 4));
  }
  //523F184D
  return v4; 
}



//@a1 字符串地址
//@a2 字符串大小
int __fastcall sub_523F4BB0(int a1, unsigned int a2)
{
  int v2; // edi@1
  int result; // eax@1
  unsigned int v4; // esi@3
  int v5; // ecx@4

  v2 = a1;
  result = 0;
  if ( a2 > 0x3E8 )
    a2 = 1000;
  v4 = 0;
  if ( a2 )
  {
    do
    {
      v5 = *(_BYTE *)(v4++ + v2);
      result = v5 + 0x83 * result; //523F4BDB,  全局搜 0x83 很多字符串处理都用了同样的逻辑, 生成一个字符串的 sign??
    }
    while ( v4 < a2 );
  }
  return result;
}

{
.text:523F4BB0
.text:523F4BB0
.text:523F4BB0 sub_523F4BB0    proc near               ; CODE XREF: Util::Convert::Utf8ToWS(char const *,int)+198p
.text:523F4BB0                                         ; sub_522B2B50+C6p ...
.text:523F4BB0                 push    esi
.text:523F4BB1                 push    edi
.text:523F4BB2                 mov     edi, ecx
.text:523F4BB4                 xor     eax, eax
.text:523F4BB6                 mov     ecx, 3E8h
.text:523F4BBB                 cmp     edx, ecx
.text:523F4BBD                 cmova   edx, ecx
.text:523F4BC0                 xor     esi, esi
.text:523F4BC2                 test    edx, edx
.text:523F4BC4                 jz      short loc_523F4BE1
.text:523F4BC6                 db      66h, 66h
.text:523F4BC6                 nop     word ptr [eax+eax+00000000h]
.text:523F4BD0
.text:523F4BD0 loc_523F4BD0:                           ; CODE XREF: sub_523F4BB0+2Fj
.text:523F4BD0                 movsx   ecx, byte ptr [esi+edi]        //  movsx 带符号扩展，并传送
.text:523F4BD4                 inc     esi
.text:523F4BD5                 imul    eax, 83h
.text:523F4BDB                 add     eax, ecx
.text:523F4BDD                 cmp     esi, edx
.text:523F4BDF                 jb      short loc_523F4BD0
.text:523F4BE1
.text:523F4BE1 loc_523F4BE1:                           ; CODE XREF: sub_523F4BB0+14j
.text:523F4BE1                 pop     edi
.text:523F4BE2                 pop     esi
.text:523F4BE3                 retn
.text:523F4BE3 sub_523F4BB0    endp
	
	
}



//创建内存
//@a6 处理后的字符串地址?
//@a2 字符串长度
//@a3 单个字符长度
_DWORD *__thiscall sub_523F4FD0(_DWORD *this, int a2, int a3, int a4, unsigned int a5, int a6, _DWORD *a7)
{
  _DWORD *v7; // edi@1
  int v8; // esi@3
  int v9; // edi@3
  int v10; // ebx@4
  int v11; // esi@6
  int v12; // edx@6
  unsigned int v13; // ecx@6
  bool v14; // cf@8
  int v15; // eax@19
  bool v16; // zf@20
  _DWORD *v17; // eax@21
  _DWORD *result; // eax@24
  int v19; // edi@31
  void *v20; // eax@31
  _DWORD *v21; // esi@31
  int v22; // eax@32
  int v23; // [sp+Ch] [bp-4h]@3

  v7 = this;
  if ( TlsGetValue(dwTlsIndex) )
  {
    v17 = a7;
    if ( a7 )
      goto LABEL_28;
LABEL_29:
    if ( a2 >= 0 && (v19 = a3 * a2, v20 = malloc(a3 * a2 + 22), (v21 = v20) != 0) ) //创建内存
    {
		//CTXBSTR 结构占20字节, a3 * a2 为字符串占用字节, 还有 2字节是结束符占用
      memset(v20, 0, v19 + 22);
      v22 = v21[3];
      v21[1] = 1; //CTXBSTR[4], (DWORD)默认为 1
      v21[3] = v22 & 1 | 2 * v19;   //CTXBSTR[12] 
      v16 = TlsGetValue(dwTlsIndex) == 0;
      result = v21;
      v21[3] = v21[3] & 0xFFFFFFFE | v16;
    }
    else
    {
      result = 0;
    }
    return result;
  }
  if ( !a4 )
    goto LABEL_29;
  v8 = a6;
  v23 = 8 * (a6 & 0x3FF);
  Util::CTXSpinLock::Lock((volatile LONG *)(dword_52528F68 + v23));
  v9 = v7[(unsigned __int16)a6 + 6];
  if ( !v9 )
  {
LABEL_19:
    v15 = v23 + dword_52528F68;
    if ( Util::CTXSpinLock::g_cProcessorNum <= 1 )
    {
      LeaveCriticalSection(*(LPCRITICAL_SECTION *)v15);
    }
    else
    {
      v16 = (*(_DWORD *)(v15 + 4))-- == 1;
      if ( v16 )
      {
        InterlockedExchange((volatile LONG *)v15, 0);
        v17 = a7;
LABEL_28:
        *v17 = 0;
        goto LABEL_29;
      }
    }
    v17 = a7;
    goto LABEL_28;
  }
  while ( 1 )
  {
    v10 = *(_DWORD *)(v9 + 4);
    if ( *(_DWORD *)(v10 + 8) != v8 || *(_DWORD *)(v10 + 16) != a5 )
      goto LABEL_18;
    v11 = a4;
    v12 = v10 + 20;
    v13 = a5 - 4;
    if ( a5 < 4 )
    {
LABEL_9:
      if ( v13 == -4 )
        break;
    }
    else
    {
      while ( *(_DWORD *)v12 == *(_DWORD *)v11 )
      {
        v12 += 4;
        v11 += 4;
        v14 = v13 < 4;
        v13 -= 4;
        if ( v14 )
          goto LABEL_9;
      }
    }
    if ( *(_BYTE *)v12 == *(_BYTE *)v11
      && (v13 == -3
       || *(_BYTE *)(v12 + 1) == *(_BYTE *)(v11 + 1)
       && (v13 == -2
        || *(_BYTE *)(v12 + 2) == *(_BYTE *)(v11 + 2) && (v13 == -1 || *(_BYTE *)(v12 + 3) == *(_BYTE *)(v11 + 3)))) )
    {
      break;
    }
    v8 = a6;
LABEL_18:
    v9 = *(_DWORD *)v9;
    if ( !v9 )
      goto LABEL_19;
  }
  if ( v10 != dword_52528F6C )
    InterlockedIncrement((volatile LONG *)(v10 + 4));
  sub_523F4C70(a6); //--->
  *a7 = 1;
  return *(_DWORD **)(v9 + 4);
} 

//字符串地址引用计数
void __fastcall sub_523F4C70(__int16 a1)
{
  int v1; // eax@1
  bool v2; // zf@2

  v1 = dword_52528F68 + 8 * (a1 & 0x3FF);
  if ( Util::CTXSpinLock::g_cProcessorNum <= 1 )
  {
    LeaveCriticalSection(*(LPCRITICAL_SECTION *)v1);
  }
  else
  {
    v2 = (*(_DWORD *)(v1 + 4))-- == 1;
    if ( v2 )
      InterlockedExchange((volatile LONG *)v1, 0);
  }
}
//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 











 

//====================================================================================================================================================



//====================================================================================================================================================


 

